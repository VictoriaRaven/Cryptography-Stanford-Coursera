<!DOCTYPE html>
<html>
<body>
<h1>My Week 1 Q1 - 10/07/2024</h1>

<h4>Question 1: </h4>
<p>
Data compression is often used in data storage and transmission. 
Suppose you want to use data compression in conjunction with encryption:
</p>
<h4>Answer and Why: </h4>
<p>Answer: Compress then encrypt.
Why: compression works best on patterns in the data, which can be obscured
by encryption and if you compress it last and encrypt it first it is less efficient. 
In addtion, Compression algorithms are designed to identify and remove redundancies 
in data, which are more easily detected when the data is in its original, unencrypted
form. Encrypting data first can scramble the patterns, making it harder for compression
algorithms to effectively reduce the size. Encrypting after compression doesn't 
compromise security, as the encryption key is still required to decrypt the data, 
even when it's compressed.</p>

<h4>Question 2: </h4>
<p>
Let G: {0,1}^s → {0,1}^n be a secure PRG. Which of the following is a secure PRG: 
</p>
<h4>Answer and Why: </h4>
<p> Answer: G'(k_1,k_2) = G(k_1)||G(k_2), (where here || denotes concatenation)...;
G'(k) = reverse(G(k)) where reverse(x) reverses the string x so that the first bit of 
x is the last bit of reverse(x), the second bit of x is the second to last bit of 
reverse(x), and so on...; G'(k) = G(k) ⊕ 1^n...;
Why: These answers are not random and are secure PRG.</p>

<h4>Question 3: </h4>
<p> 
Let G: K → {0,1}^n be a secure PRG. 
Define G'(k_1,k_2) = G(k_1) ⋀ G(k_2) where ⋀ is the bit-wise AND function.
Consider the following statisical test A on {0,1)^n:
A(x) outputs LSB(x), the least significant bit of x.
What is Adv_PRG[A,G']? You may assume that LSB(G(k)) is 0 for exactly half the seeds k in K.
Note: Please enter the advantage as a decimal between 0 and 1 with a leading 0.
If the advantage is 3/4, you should enter it as 0.75.
</p>
<h4>Answer and Why: </h4>
<p>Answer: 0.25
Why: LSB of G(k) of 0 = 0.5 (chance). LSB(G(k1)) and LSB(G(k2)) of 11 = 0.5 * 0.5 = 0.25 (chance)
This is based on the probability formula.</p>

<h4>Question 4: </h4>
<p>
Let (E,D) be a (one-time) semantically secure cipher with key space K = {0,1}^ℓ. A bank wishes
to split a decryption key k ∈ {0,1}^ℓ into two pieces p1 and p2 so that both are needed for 
decryption. The piece p1 can be given to one executive and p2 to another so that both must 
contribute their pieces for decryption to proceed. The bank generates random k_1 in {0,1}^ℓ 
and sets k_1' ← k ⊕ k_1. Note that k_1 ⊕ k_1' = k. The bank can give k_1 to one executive 
and k_1' to another. Both must be present for decryption to proceed since, by itself, each
piece contains no information about the secret key k (note that each piece is a one-time pad
encryption of k). Now, suppose the bank wants to split k into three pieces p1,p2,p3 so that 
any two of the pieces enable decryption using k. This ensures that even if one executive is 
out sick, decryption can still succeed. To do so the bank generates two random pairs 
(k_1,k_1') and (k_2,k_2') as in the previous paragraph so that k_1 ⊕ k_1'= k_2 ⊕ k_2' = k.
How should the bank assign pieces so that any two pieces enable decryption using k, but no 
single piece can decrypt?
</p>
<h4>Answer and Why: </h4>
<p>Answer: p1 = (k_1,k_2), p2 = (k_1',k_2), p3 = (k_2')
Why: When 2 is together 1,2,5 cannot decrypt and 4 can de decrypt only if there is p2.
This makes that 3 is the solution for this answer for k_2' </p>

<h4>Question 5: </h4>
<p>
Let M = C = K = {0,1,2,…,255} and consider the following cipher defined over 
(K,M,C): E(k,m) = m + k(mod 256); D(k,c) = c−k(mod 256) Does this cipher have perfect secrecy?
</p>
<h4>Answer and Why: </h4>
<p>Answer: YES, This code has perfect secrecy based on the lectures and the chances.
Why:  This code has perfect secrecy based on the lectures and the chances.</p>

<h4>Question 6: </h4>
<p> Let (E,D) be a (one-time) semantically secure cipher where the message and 
ciphertext space is {0,1}^n. Which of the following encryption schemes are (one-time) 
semantically secure?
</p>
<h4>Answer and Why: </h4>
<p>Answer: E'((k,k'),m) = E(k,m) || E(k',m); E'(k,m) = reverseE(E(k,m); 
E'(k,m) = 0 || E(k,m) (i.e. prepend 0 to the ciphertext) 
Why: For breaking semantic security, attacker encryption of 0^n and 1^n and knows the secret key, namely 0^n.
For breaking semantic security, attacker encryption of 0n and 0^(n-1)1 and can distinguish EXP(0) from EXP(1).
For breaking semantic security, attacker read the secret key from ciphertext and decrypts ciphertext where
ciphertext reveals the secret key.
</p>

<h4>Question 7: </h4>
<p>Suppose you are told that the one time pad encryption of the message "attack at dawn" is
6c73d5240a948c86981bc294814d (the plaintext letters are encoded as 8-bit ASCII and the given ciphertext is 
written in hex). What would be the one time pad encryption of the message "attack at dusk" under the same 
OTP key?
Answer: 
</p>
<h4>Answer and Why: </h4>
<p>Answer: 
Why: Given the original message and encoded cypher, we can recover that key=. 
After XORing the key with the new message, we get the correct answer </p>

<h4>Question 8: </h4>
<p>
The movie industry wants to protect digital content distributed on DVD’s. We develop a variant of a method used to protect Blu-ray disks called AACS.
Suppose there are at most a total of n DVD players in the world (e.g. n=232). We view these n players as the leaves of a binary tree of height log2n. 
Each node in this binary tree contains an AES key ki. These keys are kept secret from consumers and are fixed for all time. At manufacturing time each 
DVD player is assigned a serial number i∈[0,n−1]. Consider the set of nodes Si along the path from the root to leaf number i in the binary tree. 
The manufacturer of the DVD player embeds in player number i the keys associated with the nodes in the set Si. A DVD movie m is encrypted as
E(kroot,k)||E(k,m) where k is a random AES key called a content-key and kroot is the key associated with the root of the tree. Since all DVD players 
have the key kroot all players can decrypt the movie m. We refer to E(kroot,k) as the header and E(k,m) as the body. In what follows the DVD header 
may contain multiple ciphertexts where each ciphertext is the encryption of the content-key k under some key ki in the binary tree.
Suppose the keys embedded in DVD player number r are exposed by hackers and published on the Internet. In this problem we show that when the movie 
industry distributes a new DVD movie, they can encrypt the contents of the DVD using a slightly larger header (containing about log2n keys) so that
all DVD players, except for player number r, can decrypt the movie. In effect, the movie industry disables player number r without affecting other players.
As shown below, consider a tree with n=16 leaves. Suppose the leaf node labeled 25 corresponds to an exposed DVD player key. Check the set of keys below under 
which to encrypt the key k so that every player other than player 25 can decrypt the DVD. Only four keys are needed.
</p>
<h4>Answer and Why: </h4>
<p>Answer: 6,11,1,26
Why: To Exclude 25, Include all elements under keys 6,11,1,26.</p>

<h4>Question 9: </h4>
<p>Continuing with the previous question, if there are n DVD players, what is the number of keys under which the content key 
k must be encrypted if exactly one DVD player's key needs to be revoked? 
</p>
<h4>Answer and Why: </h4>
<p>Answer: log_2 n
Why: To Exclude 25, Include all elements under key 1, 6 and 11, 26.
</p>

<h4>Question 10: </h4>
<p>Continuing with question 8, suppose the leaf nodes labeled 16, 18, and 25 correspond to exposed DVD player keys. Check the smallest set
of keys under which to encrypt the key k so that every player other than players 16,18,25 can decrypt the DVD.  Only six keys are needed.
</p>
<h4>Answer and Why: </h4>
<p>Answer: 15,17,6,4,26,11
Why: To Exclude 16,18,25, Include all elements under keys 15,17,6,4,26,11.</p>


</body>
</html>
